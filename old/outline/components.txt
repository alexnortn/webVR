




Alex Norton
2016
-


Selected Components

Camera

	The camera component defines from which perspective the user views the scene. It is often paired with controls components that allow input devices to move and rotate the camera.

	It is recommended to wrap entities with the camera component within another entity. This allows us to change the position and rotation of the camera without colliding with controls.

	Example

	A camera situated at human-level height (1.8 meters).

		<a-entity camera="userHeight: 1.8" look-controls></a-entity>

	Properties

		+ active
		+ far
		+ fov
		+ near
		+ userHeight
		+ zoom

	Fixing Entities to the Camera

	To fix entities onto the camera such that they stay within view no matter where the user looks, you can attach those entities as a child of the camera. Use cases might be a heads-up display (HUD).

		<a-entity camera look-controls>
			<a-entity geometry="primitive: plane; 
								height: 0.2;
								width: 0.2" 
					  position="0 0 -1"
					  material="color: gray; 
					  			opacity: 0.5">
			</a-entity>
		</a-entity>

	Note that you should use HUDs sparingly as they cause irritation and eye strain in VR. Consider integrating menus into the fabric of the world itself. If you do create a HUD, make sure that it is more in the center of the field of view such that the user does not have to strain their eyes to read it.


Cursor

	The cursor component lets us inteact with entities through clicking and gazing. It is a specific application of the raycaster component in that it:

		+ Listens for mouse clicks and gazed based fuses.
		+ Captures on the first intersected entity.
		+ Emits special mouse and hover events (e.g., relating mouse down/up/enter/leave).
		+ Has additional states for hovering.

	When the mouse is clicked, the closest visible entity intersecting the cursor, if any, will emit a click event. Note the cursor component only applies raycasting behavior. To provide share or appearance to the cursor, you could apply the geometry and material components.

	
	Example

	For example, we can create a ring-shaped cursor that is fixed to the center of the screen. To fix it to the screen such that it is always present no matter where we look, we place it as a child of the active camera entity. We pull it in front of the camera by placing it on the negative Z axis. When the cursor clicks on the box, we can listen to the click event.

		<a-entity camera>
			<a-entity cursor="fuse: true; fuseTimeout: 500"
					  position="0 0 -1"
					  geometry="primitive: ring"
					  material="color: black; shader: flat">
			</a-entity>
		</a-entity>
		<a-entity id="box" cursor-listener geometry="primitive: box" material="color: blue"></a-entity>

		<script type="text/javascript">
			
			// Component to change to random color on click.
			AFRAME.registerComponent('click-color-change', {
				init: function () {
					var COLORS = ['red', 'green', 'blue'];
					this.el.addEventListener('click', function () {
						var randomIndex = Math.floor(Math.random() * COLORS.length);
						this.setAttribute('material', 'color', COLORS[randomIndex]);
						console.log('I was clicked!');
					});
				}
			});

		</script>

		
		Properties

		Note, to further customize the cursor component, we can set the properties of the raycaster component.

			+ fuse - whether cursor is fused-based
			+ fuseTimeout


		Events

			+ click
			+ mousedown
			+ mouseenter
			+ mouseleave
			+ mouseup

		
		States

			+ cursor-fusing
			+ cursor-hovering

		
		Configuring the Cursor through the Raycaster Component

		The cursor is built on top of and depends on the raycaster component. If we want to customize the raycasting pieces of the cursor, we can do by changing the raycaster component properties. Say we want set a max distance, check for intersections less frequently, and set which objects are clickable:

		<a-entity cursor raycaster="far: 20; interval: 1000; objects: .clickable"></a-entity>


		Fuse-Based Cursor

		Also known as gaze-based cursor. If the cursor is set to be fuse-based, the cursor will trigger a click if the user gazes at an entity for a set amount of time. Imagine a laser strapped to the user’s head, and the laser extends out into the scene. If the user stares at an entity long enough (i.e., the fuseTimeout), then the cursor will trigger a click.

		The advantage of fuse-based interactions for VR is that it does not require additional input devices other than the headset. It is primarily intended for Google Cardboard applications. The disadvantage of fuse-based interactions is that it requires the user to turn their head a lot.


		Adding Visual Feedback

		To add visual feedback to the cursor in order to display indication when the cursor is clicking or fusing, we can use the animation system. When the cursor intersects the entity, it will emit an event, and the animation system will pick up event with the begin attribute:

			<a-entity cursor="fuse: true; timeout: 500"
					  position="0 0 -1"
					  geometry="primitive: ring"
					  material="color: black; shader: flat">
				<a-animation begin="click" easing="ease-in" attribute="scale"
							 fill="backwards" from="0.1 0.1 0.1" to="1 1 1">
				2</a-animation>
				<a-animation begin="cursor-fusing" easing="ease-in" attribute="scale"
							 fill="forwards" from="1 1 1" to="0.1 0.1 0.1">
				</a-animation>
			</a-entity>

		
		---
		Definitely need to show off the Fusing + Gazing interaction --> That's a new one.


	Geometry

		The geometry component provides a basic shape for an entity. The general geometry is defined by the primitive property. Geometric primitives, in computer graphics, means an extremely basic shape. With the primitive defined, additional properties are used to further define the geometry. A material component is usally defined to provide an appearance alongside the shape to careate a complete mesh.


		Basic Properties

		Every geometry type will have these properties:

			+ buffer - 	Transform geometry into a BufferGeometry to reduce memory usage at the cost of being harder to manipulate.	
			+ mergeTo - A selector to an entity to merge the entity’s geometry to.
			+ primitive - Name of a geometry (e.g., one of the geometries listed below). Determines the geometry type and what other properties are available.
			+ skipCache - Disable retrieving the shared geometry object from the cache.


		Built-In Geometries

			Box

			The box geometry defines boxes.
			<a-entity geometry="primitive: box; width: 1; height: 1; depth: 1"></a-entity>

				+ width
				+ height
				+ depth

			
			Circle

			The circle geometry creates flat two-dimensional circles. These can be complete circles or partial circles (like Pac-Man). Note that because it is flat, only a single side of the circle will be rendered if “side: double” is not specified on the material component.

			<a-entity geometry="primitive: circle; radius: 1" material="side: double"></a-entity>

				+ radius
				+ segments - Number of triangles to construct the circle, like pizza slices.
				+ thetaStart - Start angle for the first segment. (circle start).
				+ thetaLength - The central area (in degrees). Defaults to 360. (circle end).

			
			Cone

			The cone geometry is a cylinder geometry that have different top and bottom radii.
			<a-entity geometry="primitive: cone; radiusBottom: 1; radiusTop: 0.1"></a-entity>

				+ height
				+ openEnded
				+ radiusBottom
				+ radiusTop
				+ segmentsRadial
				+ segmentsHeight
				+ thetaStart
				+ thetaEnd

			
			Cylinder

			The cylinder geometry creates cylinders in the traditional sense like a Coca-Cola™ can, but it can also define shapes such as tubes and curved surfaces.

			We can create a basic cylinder using height and radius:

			<a-entity geometry="primitive: cylinder; height: 3; radius: 2"></a-entity>

			We can create a tube by making the cylinder open-ended, which removes the top and bottom surfaces of the cylinder such that the inside is visible. Then a double-sided material will be needed to render properly:

			<!-- Tube -->
			<a-entity geometry="primitive: cylinder; openEnded: true" 
					  material="side: double">
			</a-entity>

			We can create a cured surfaces by specifying the arc via thetaLength such that the cylinder doesn’t curve all the way around, making the cylinder open-ended, and then making the material double-sided:

			<!-- Curved surface -->
			<a-entity geometry="primitive: cylinder; openEnded: true; thetaLength: 180"
         			  material="side: double">
         	</a-entity>

				+ height
				+ openEnded
				+ radiusBottom
				+ radiusTop
				+ segmentsRadial
				+ segmentsHeight
				+ thetaStart
				+ thetaEnd

			We can create prisms by changing the number of radial segments (i.e., sides). For example, to make a hexagonal prism:

			<!-- Hexagonal prism -->
			<a-entity geometry="primitive: cylinder; segmentsRadial: 6"></a-entity>

			
			Plane

			The plane geometry creates a flat surface. Because it is flat, only a single side of the plane will be rendered unless side: double is specified on the material component.

			<a-entity geometry="primitive: plane; height: 10; width: 10" 
					  material="side: double">
			</a-entity>

				+ width
				+ height


			Ring

			The ring geometry creates a flat ring, like a CD. Because it is flat, only a single side of the ring will be rendered unless side: double is specified on the material component.

			<a-entity geometry="primitive: ring; radiusInner: 0.5; radiusOuter: 1"
          			  material="side: double">
          	</a-entity>

          		+ radiusInnter
          		+ radiusOutter
          		+ segmentsTheta
          		+ segmentsPhi
          		+ thetaStart
          		+ thetaLength


          	Sphere

          	The sphere geometry creates spheres (e.g., balls). We can create a basic sphere:

          	<a-entity geometry="primitive: sphere; radius: 2"></a-entity>

          	We can create various polyhedrons and abstract shapes by specifying the number of horizontal angles and faces:

          	<a-entity geometry="primitive: sphere; segmentsWidth: 2; segmentsHeight: 8"></a-entity>

          		+ radius
          		+ segmentsWidth
          		+ segmentsHeight
          		+ phiStart
          		+ phiLength
          		+ thetaStart
          		+ thetaLength


      		Register a Custom Geometry

      		We can register our own geometries using AFRAME.registerGeometry and creating an object that is an instance of THREE.Geometry. All built-in geometries in A-Frame are registered using this API.

      		Here is how the box geometry is registered.

      		<script type="text/javascript">
      			
      			AFRAME.registerGeometry('box', {
				  schema: {
				    depth:  {default: 1, min: 0},
				    height: {default: 1, min: 0},
				    width:  {default: 1, min: 0},
				    segmentsHeight: {default: 1, min: 1, max: 20, type: 'int'},
				    segmentsWidth:  {default: 1, min: 1, max: 20, type: 'int'},
				    segmentsDepth:  {default: 1, min: 1, max: 20, type: 'int'}
				  },
				  init: function (data) {
				    this.geometry = new THREE.BoxGeometry(data.width, data.height, data.depth);
				  }
				});

      		</script>

      		Like with registering components, we provide a name, a schema that will expose the properties of the geometry, and lifecycle methods. Then the geometry needs to be created and set on this.geometry through the init and update lifecycle methods.

      		When a geometry component sets its primitive property to the custom geometry name, the properties of the custom geometry can be set on the geometry component. Say we registered a custom geometry:

      		<script type="text/javascript">
      			
				AFRAME.registerGeometry('example', {
				  schema: {
				    vertices: {
				      default: ['-10 10 0', '-10 -10 0', '10 -10 0'],
				    }
				  },
				  init: function (data) {
				    var geometry = new THREE.Geometry();
				    geometry.vertices.push.call(
				      geometry.vertices,
				      data.vertices.map(function (vertex) {
				        var points = vertex.split(' ').map(parseInt);
				        return new THREE.Vector3(points[0], points[1], points[2]);
				      });
				    );
				    geometry.faces.push(new THREE.Face3(0, 1, 2));
				    this.geometry = geometry;
				  }
				});

      		</script>

      		We can then use that custom geometry in HTML:

      		<a-entity geometry="primitive: example; vertices: 1 1 1, 2 2 2, 3 3 3"></a-entity>

      		
      		---
      		No need to go into custom geometry, but explaining basic shapes could be useful, think of what we need to build a basketball court.


  		Light

  			The light component defines the entity as a source of light. Light affects all materials that have not specified a flat shading model with shader: flat. Note that lights are computationally expensive and the number of lights in a scene should be limited.

  			<a-entity light="color: #AFA; intensity: 1.5" position="-1 1 0"></a-entity>

  			By default, A-Frame scenes inject default lighting, an ambient light and a directional light. These default lights are visible in the DOM with the data-aframe-default-light attribute. Whenever any lights are added, the default lights are removed from the scene.

  			<!-- Default lighting injected by A-Frame. -->
			<a-entity light="type: ambient; color: #BBB"></a-entity>
			<a-entity light="type: directional; color: #FFF; intensity: 0.6"
					  position="-0.5 1 1">
			</a-entity>


			Properties

			We will go through the different types of lights and their respective properties one by one.

				+ type - ambient, directional, hemisphere, point, spot | directional
				+ color | #fff
				+ intensity - light strength | 1.0


			Ambient

			Ambient lights are applied to all entities in the scene globally. They are defined by the color and intensity properties. Additionally, position, rotation, and scale have no effect on ambient lights.

			It is recommended to have some form of ambient light such that shadowed areas are not completely black and to mimic indirect lighting.

			<a-entity light="type: ambient; color: #CCC"></a-entity>


			Directional

			Directional lights can be thought of as a light source infinitely far away, but shining from a specific direction, like the sun. Thus, absolute position do not have an effect on the intensity of the light on an entity. We can specify the direction using the position component.

			The example below creates a light source shining from the upper-left at a 45-degree angle. Note that because only the vector matters, position="-100 100 0" and position="-1 1 0" are equivalent.

			<a-entity light="type: directional; color: #EEE; intensity: 0.5"
					  position="-1 1 0">
			</a-entity>

			It is also possible to specify the direction of the directional light with it’s orientation by creating a child entity it targets. for example pointing down it’s -Z axis:

			<a-light type="directional" 
					 position="0 0 0"
					 rotation="-90 0 0"
					 target="#directionaltarget">
				<a-entity id="directionaltarget" position="0 0 -1"></a-entity>
			</a-light>

			^ Look At


			Hemisphere

			Hemisphere lights can be thought of as an ambient light, but with two colors of light, one from above (color) and one from below (groundColor). This can be useful for scenes with two distinct lighting colors (e.g., a grassy field under a gray sky).

			<a-entity light="type: hemisphere; 
							 color: #33C; 
							 groundColor: #3C3; 
							 intensity: 2">
			</a-entity>

				+ groundColor - light color from below | #fff


			Point

			Point lights, unlike directional lights, are omni-directional and affect materials depending on their position and distance. They can be thought of as a light bulb. The closer the light bulb gets to an object, the greater the object is lit.

			<a-entity light="type: point; intensity: 0.75; distance: 50; decay: 2"
      				  position="0 10 10">
      		</a-entity>

      			+ decay - Amount the light dims along the distance of the light. | 1.0
      			+ distance - Distance where intensity becomes 0. If distance is 0, then the point like does not decay with distance. | 0.0.


  			Spot

  			Spot lights are like point lights in the sense that they affect materials depending on its position and distance, but spot lights are not omni-directional. They mainly cast light in one direction, like the Bat-Signal.

  			<a-entity light="type: spot; angle: 45"></a-entity>

  				+ angle - Maximum extent of spot light from its direction (in degrees) | 60.
  				+ decay - Amount the light dims along the distance of the light. | 1.0
  				+ distance - Distance where intensity becomes 0. If distance is 0, then the point like does not decay with distance. | 0.0.
  				+ penumbra - Percent of the spotlight cone that is attenuated due to penumbra | 0.0
  				+ target - Element the spot should point to. Set to null to transfrom spotlight by orientation, pointing to it's -Z axis.


		Look-Controls

			The look-controls component defines the following behavior of an entity. The look-controls component acts upon the HMD headset, mouse, and touchscreen inputs. A-Frame standard controls are grouped together based upon configuration and behavior rather than by individual input methods:

				+ Rotate when the head-mounted display (HMD) is rotated.
				+ Rotate when the mouse is clicked and dragged.
				+ Rotate when the touchscreen is tapped and dragged.

			
			Example

			The look-controls component is usually used alongside the [camera component] [components-camera].

			<a-entity camera look-controls></a-entity>


			Properties

				+ enabled - Whether look controls are enabled | true


			Caveats

			If you want to create your own component for look controls, you will have to copy and paste the HMD-tracking bits into your component. In the future, we may have a system for people to more easily implement their controls.


		Material

			The material component gives appearance to an entity. We can define properties such as color, opacity, or texture. This is often paired with the geometry component which provides shape.

			Custom materials and shaders can be registered to extend the material component in order to provide a wide range of visual effects.


			Example

			Defining a red material using the default standard material:

				<a-entity geometry="primitive: box" 
						  material="color: red">
				</a-entity>

			Here is an example of using a different material:

				<a-entity geometry="primitive: box" 
						  material="shader: flat; color: red">
				</a-entity>

			Here is an example of using an example custom material:

				<a-entity geometry="primitive: plane"
          				  material="shader: ocean; color: blue; wave-height: 10">
          		</a-entity>


      		Properties

      		The material component has a few base properties. More properties will be available depending on the material applied.

      			+ depthTest   - Whether depth testing is enabled when rendering the material | true
      			+ flatShading - Use THREE.FlatShading rather than THREE.StandardShading | true
      			+ opacity     - Extent of transparency. If the transparent property is not true, then the material will remain opaque and opacity will only affect color | 1.0
      			+ shader      - Which material to use. Defaults to the standard material. Can be set to the flat material or to a registered custom material. | standard
      			+ side        - Which sides of the mesh to render. Can be front, back, or double | front
      			+ visible     - whether material is visible. Raycasters will ignore invisible materials | true.


  			Events

  				+ materialtextureloaded
  				+ materialvideoended


			Built-In Materials

			A-Frame ships with a few built-in materials.

				standard

				The standard material is the default material. It uses the physically-based THREE.MeshStandardMaterial.

				Properties

					+ color - Base diffuse color | #fff
					+ height - Height of video (in pixels), if defining a video texture | 360
					+ envMap - Environment cubemap texture for reflections. Can be a selector to a csv list of URLs. | none
				 	+ fog - Whether or not the material is affected by fog | true
				 	+ metalness - How metallic the material is from 0 to 1 | 0.5
				 	+ repeat - How many times a texture (defined by src) reapeats in X and Y direction | 1 1
				 	+ roughness - How rough the material is from 0 to 1. A rougher material will scatter reflected light in more directions than a smooth material | 0.5
				 	+ width - Width of video (in pixels), if defining a video texture | 640
				 	+ src - Image or video texture map. Can either be a selector to an <img> or <video>, or an inline URL | none


		 	Physically-Based Shading

		 	Physically-based shading is a shading model that aims to make materials behave realistically to lighting conditions. Appearance is a result of the interaction between the incoming light and the properties of the material.

			To achieve realism, the diffuse color (can be supplied through the base material component), metalness, roughness properties of the material must be accurately controlled, often based on real-world material studies. Some people have compiled charts of realistic values for different kinds of materials that can be used as a starting point.

			For example, for a tree bark material, as an estimation, we might set:

			<a-entity geometry="primitive: cylinder"
			          material="src: treebark.png; color: #696969; roughness: 1; metalness: 0">
			</a-entity>


			Environment Maps

			The envMap property defines what environment the material reflects. Unlike textures, the envMap property takes a cubemap, six images put together to form a cube. The cubemap is wrapped around the mesh and applied as a texture. The clarity of the environment depends on the metalness, and roughness properties.

			For example:

			<a-scene>
			  <a-assets>
			    <a-cubemap id="sky">
			      <img src="right.png">
			      <img src="left.png">
			      <img src="top.png">
			      <img src="bottom.png">
			      <img src="front.png">
			      <img src="back.png">
			    </a-cubemap>
			  </a-assets>
			  <a-entity geometry="primitive: box" material="envMap: #sky; roughness: 0"></a-entity>
			</a-scene>


			Flat

			The flat material uses the THREE.MeshBasicMaterial. Flat materials are not affected by the scene’s lighting conditions. This is useful for things such as images or videos or other GUI elements. Set shader to flat:

			<a-entity geometry="primitive: plane" 
					  material="shader: flat; src: #cat-image">
			</a-entity>

			Properties

				+ color - Base diffuse color | #fff
			 	+ fog - Whether or not the material is affected by fog | true
				+ height - Height of video (in pixels), if defining a video texture | 360
			 	+ repeat - How many times a texture (defined by src) reapeats in X and Y direction | 1 1
			 	+ src - Image or video texture map. Can either be a selector to an <img> or <video>, or an inline URL | none
			 	+ width - Width of video (in pixels), if defining a video texture | 640


		 	Textures

		 	To set a texture using one of the built-in materials, specify the src property. src can be a selector to either an <img> or <video> element in the asset management system:

		 	<a-scene>
			  <a-assets>
			    <img id="my-texture" src="texture.png">
			  </a-assets>
			  <a-entity geometry="primitive: box" material="src: #my-texture"></a-entity>
			</a-scene>

			src can also be an inline URL. Note that we do not get browser caching or preloading through this method.

			<a-scene>
			  <a-entity geometry="primitive: box" material="src: url(texture.png)"></a-entity>
			</a-scene>

			Most of the other properties work together with textures. For example, the color property will act as the base color and be multiplied per pixel with the texture. Set it to #fff to maintain the original colors of the texture.

			Textures are cached by A-Frame in order to not push redundant textures to the GPU.


			Video Textures

			Whether the video texture loops or autoplays depends on the video element used to create the texture. If we simply pass a URL instead of creating and passing a video element, then the texture will loop and autoplay by default. To specify otherwise, create a video element in the asset management system, and pass a selector for the id attribute (e.g., #my-video):

			<a-scene>
			  <a-assets>
			    <!-- No loop. -->
			    <video id="my-video" src="video.mp4" autoplay="true">
			  </a-assets>
			  <a-entity geometry="primitive: box" material="src: #my-video"></a-entity>
			</a-scene>

			Controling Video Textures

			To control the video playback such as pausing or seeking, we can use the video element to control media playback. For example:

			<script type="text/javascript">
				
				var videoEl = document.querySelector('#my-video');
				videoEl.currentTime = 122;  // Seek to 122 seconds.
				videoEl.pause();

			</script>

			--- 
			There is more here, but that's way beyond what we have time for.


		Obj-Model

			The obj-model component loads a 3D model and material using a Wavefront (.OBJ) file and a .MTL file.

			Example

			We can load an .OBJ model by pointing to assets that specify the path to an .OBJ and .MTL file:

			<a-scene>
			  <a-assets>
			    <a-asset-item id="tree-obj" src="/path/to/tree.obj"></a-asset-item>
			    <a-asset-item id="tree-mtl" src="/path/to/tree.mtl"></a-asset-item>
			  </a-assets>
			  <a-entity obj-model="obj: #tree-obj; mtl: #tree-mtl"></a-entity>
			</a-scene>


			Properties

				+ obj - Selector to and <a-asset-item> pointing to a .OBJ file or inline to path
				+ mtl - Selector to and <a-asset-item> pointing to a .MTL file or inline to path. Optional if you wish to use the material component instead.

			---
			Might be useful to demo, maybe we load the "Stadium"


		Position

			The position component defines where an entity is placed in the scene’s world space. It takes a coordinate value as three space-delimited numbers.

			All entities inherently have the position component.

			Example

			<a-entity position="0 1 -1"></a-entity>


			Relative Positioning

			World-space positions of child entities are inherited from parent entities. Consider this scene:

			<a-entity id="parent" position="1 2 3">
			  <a-entity id="child-1"></a-entity>
			  <a-entity id="child-2" position="2 3 4"></a-entity>
			</a-entity>

			The world-space position of #child1 would be 1 2 3 as inherited by the entity. In the local parent’s space, #child1‘s position would be seen as 0 0 0.

			The world-space position of #child2 would be 3 5 7, by combining the position with the parent entity. In the parent’s local space, #child2‘s position would be seen as 2 3 4.

			--- 
			Super useful


		Raycaster

			The raycaster component does general intersection testing with a raycaster. Raycasting is the method of extending a line from an origin towards a direction, and checking whether that line intersects with other entites. The raycaster component is a wrapper on top of the three.js raycaster. It checks for intersections at a certain interval against a list of objects, and will emit events on the entity when it detects intersections or clearing of intersections (i.e., when the raycaster is no longer intersecting an entity).

			The raycaster component is what the cursor component is built upon.

			Example

			<a-entity id="player" collider-check>
				<a-entity raycaster="objects: .collidable"
						  position="0 -0.9 0"
						  rotation="90 0 0">
				</a-entity>
			</a-entity>
			<a-entity class="collidable"
					  geometry="primitive: box"
					  position="1 0 0">
			</a-entity>

			<script type="text/javascript">
				
				AFRAME.registerComponent('collider-check', {
				  dependencies: ['raycaster'],
				  init: function () {
				    this.el.addEventListener('raycaster-intersected', function () {
				      console.log('Player hit something!');
				    });
				  }
				});

			</script>


			Properties

				+ far - Maximum distance under which resulting entities are returned. Cannot be lower than near. | Inifity
				+ interval - Number of millisecondsto wait between each intersection test | 100
				+ near - Minimum distance over which resulting entities are returned. Cannot be lower than 0 | 0
				+ objects - Query selector to pick which objects to test for intersection. If not specified all entities will be tested | null
				+ recursive - Check all children of objecst if set. Else only checks intersections with root objects | true


			Events

				+ raycaster-intersected - Emitted on the intersected entity. Entity is intersecting with a raycaster. Event detail will contain el, the raycasting entity, and intersection, an object containing detailed data about the intersection.
				+ raycaster-intersected-cleared - Emitted on the intersected entity. Entity is no longer intersecting with a raycaster. Event detail will contain el, the raycasting entity.
				+ raycaster-intersection - Emitted on the raycasting entity. Raycaster is intersecting with one or more entities. Event detail will contain els, an array with the intersected entities, and intersections, an array of objects containing detailed data about the intersections.
				+ raycaster-intersection-cleared - Emitted on the raycasting entity. Raycaster is intersecting with one or more entities. Event detail will contain els, an array with the intersected entities, and intersections, an array of objects containing detailed data about the intersections.


			Members

				+ intersectedEls - Entities currently intersecting the raycaster
				+ objects - three.js objects to test for intersections. Will be scene.children if objects property is not specified.
				+ raycaster - three.js raycaster object


			Methods

				+ refreshObject - Refreshes the list of objects based off of the objects property to test for intersection.


			Setting the Origin and Direction of the Raycaster

			The raycaster has an origin, where its ray starts, and a direction, where the ray goes.

			The origin of the raycaster is at the raycaster entity’s position. The origin of the raycaster can be changed by setting the position component of the raycaster entity (or parent entities of the raycaster entity).

			The direction of the raycaster is in “front” of the raycaster entity (i.e., 0 0 -1, on the negative Z-axis). The direction of the raycaster can be changed by setting the rotation component of the raycaster entity (or parent entities of the raycaster entity).

			For example, here is applying a raycaster along the length of a rotated bullet:

			<!-- Bullet, rotated to be parallel with the ground. -->
			<a-entity id="bullet" geometry="primitive: cylinder; height: 0.1" rotation="-90 0 0">
				<!-- Raycaster, targets enemies, made to be as long as the bullet, positioned to the start of the bullet, rotated to align with the bullet. -->
				<a-entity raycaster="objects: .enemies; far: 0.1"
						  position="0 -0.5 0"
						  rotation="90 0 0">
				</a-entity>
			</a-entity>


			Whitelisting Entities to Test for Intersection

			We usually don’t want everything in the scene to be tested for intersections (e.g., for collisions or for clicks). It is also good for performance to limit the number of entities to test for intersection since it is an operation that will usually run many times per second.

			To select or pick the entities we want to test for intersection, we can use the objects property. If this property is not defined, then every object in the scene will be tested for intersection. objects takes a query selector value:

			<a-entity cursor raycaster="objects: .clickable"></a-entity>
			<a-entity class="clickable"
					  geometry="primitive: box"
					  position="1 0 0">
			</a-entity>
			<a-entity class="not-clickable"
					  geometry="primitive: sphere"
					  position="-1 0 0">
			</a-entity>

			---
			We should probably set up the "clickable" class but not go too far into the raycaster technical details. Simply explaining it with a simple interactive scene should do nicely.


		Rotation

			The rotation component defines the orientation of an entity. It takes the roll (x), pitch (y), and yaw (z) as three space-delimited numbers indicating degrees of rotation.

			All entities inherently have the rotation component.

			<a-entity rotation="45 90 180"></a-entity>


			Value

			A-Frame uses a right-handed coordinate system. When aligning our right hand’s thumb with a positive axis, our hand will curl in the positive direction of rotation.

				+ x - Roll,  rotation about the X-axis | 0
				+ y - Pitch, rotation about the Y-axis | 0
				+ Z - Yaw,   rotation about the Z-axis | 0


			Relative Rotation

			World-space rotations of child entities are inherited from parent entities. Consider this scene:

			<a-entity id="parent" rotation="0 45 0">
				<a-entity id="child-1"></a-entity>
				<a-entity id="child-2" rotation="15 45 30"></a-entity>
			</a-entity>

			The world-space rotation of #child1 would be 0 45 0 as inherited by the entity. In the local parent’s space, #child1‘s rotation would be seen as 0 0 0.

			The world-space rotation of #child2 would be 15 90 30, by combining the rotation with the parent entity. In the parent’s local space, #child2‘s rotation would be seen as 15 45 30.

			---
			Rotation deserves a slide --> Transformations deserve a quick segment


		Scale

			The scale component defines a shrinking, stretching, or skewing transformation of an entity. It takes three scaling factors for the X, Y, and Z axes.

			All entities inherently have the scale component.

			The example below shrinks the entity in half along the X direction, maintains the same scale factor along the Y direction, and stretches the entity by two-fold along the Z-direction:

			<a-entity scale="0.5 1 2"></a-entity>


			Value

			A-Frame uses a right-handed coordinate system. When aligning our right hand’s thumb with a positive axis, our hand will curl in the positive direction of rotation.

			If any of the scaling factors are set to 0, then A-Frame will assign instead an extremely small value such that things don’t break.

				+ x | 1
				+ y | 1
				+ z | 1


			Reflection

			Scaling factors can be negative, which results in a reflection.

			A notable use for this is for sky spheres. Sky spheres contain the entire scene and have a texture mapped on the interior surface. To accomplish this, we can reflect, or invert, the sphere in the Z-direction.

			<a-entity geometry="primitive: sphere; radius: 1000"
          			  material="src: sky.png"
          			  scale="1 1 -1">
          	</a-entity>

          	---
			Scale deserves a slide --> Transformations deserve a quick segment


		Sound

			The sound component defines the entity as a source of sound or audio. The sound component is positional and is therefore affected by the components-position.

			<a-entity id="river" geometry="primitive: plane" 
								 material="color: blue"
          						 position="-10 0 0" 
          						 sound="src: url(river.mp3); autoplay: true">
          	</a-entity>


          	Properties

          		+ autoplay | false
          		+ on - An event to for the entity to listen before playing the sound | null
          		+ loop | false
          		+ src | null
          		+ volume | 1


      		Events

      			+ sound-ended


  			Playing on an Event

  			The sound component can also listen to an event before playing as well. For example, we might have a laughing sound play every time a monster is clicked:

			<a-entity cursor position="0 0 -5"></a-entity>
			<a-entity id="elmo" geometry="primitive: box" 
								material="src: elmo.png"
								sound="src: url(ticklelaugh.mp3); on: click"> <!-- multi-prop -->
			</a-entity>


			Preloading a Sound Asset

			For performance, it is recommended to block the scene on the sound asset to preload and cache. We can do so through the asset management system:

			<a-scene>
			  <a-assets>
			    <audio id="river" src="river.mp3">
			  </a-assets>
			  <a-entity sound="src: #river"></a-entity>
			</a-scene>


			Pause and Resume

			To programmatically pause or resume a playing sound, we can tell the entity to pause or resume:

			<script type="text/javascript">
				
				var entity = document.querySelector('[sound]');
				entity.pause();

			</script>

			Or to pause only the sound:

			<script type="text/javascript">
				
				entity.components.sound.pause();

			</script>

			Then call .play() on either the entity or the sound component to resume.

			---
			Sound is definitely useful, why not add a bit of interaction Though, given that this is a Cardboard project, maybe sound is not necessary. Let's put sound at the end of the list.


		











			













